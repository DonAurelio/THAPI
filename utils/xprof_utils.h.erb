#include <string>
#include <iomanip>
#include <climits>
#include <unordered_map>
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>

#include "babeltrace2/babeltrace.h"

typedef int64_t     process_id_t;
typedef uint64_t    thread_id_t;
typedef std::string hostname_t;
typedef std::string thapi_command_name;
typedef uint64_t thapi_device_id;


typedef std::tuple<hostname_t, process_id_t> hp_t;
typedef std::tuple<hostname_t, process_id_t, thread_id_t> hpt_t;
typedef std::tuple<hostname_t, process_id_t, thread_id_t, thapi_command_name> hpt_command_name_t;
typedef std::tuple<thread_id_t, thapi_command_name> t_command_name_t;
typedef std::tuple<hostname_t, process_id_t, thread_id_t, thapi_device_id> hpt_device_t;
typedef std::tuple<hostname_t, process_id_t, thread_id_t, thapi_device_id, thapi_command_name> hpt_device_command_name_t;
typedef std::tuple<hostname_t, process_id_t, thapi_device_id> hp_device_t;

// https://stackoverflow.com/questions/7110301/generic-hash-for-tuples-in-unordered-map-unordered-set
// Hash of std tuple
namespace std{
    namespace
    {
        // Code from boost
        // Reciprocal of the golden ratio helps spread entropy
        //     and handles duplicates.
        // See Mike Seymour in magic-numbers-in-boosthash-combine:
        //     https://stackoverflow.com/questions/4948780
        template <class T>
        inline void hash_combine(std::size_t& seed, T const& v)
        {
            seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);
        }

        // Recursive template code derived from Matthieu M.
        template <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>
        struct HashValueImpl
        {
          static void apply(size_t& seed, Tuple const& tuple)
          {
            HashValueImpl<Tuple, Index-1>::apply(seed, tuple);
            hash_combine(seed, get<Index>(tuple));
          }
        };

        template <class Tuple>
        struct HashValueImpl<Tuple,0>
        {
          static void apply(size_t& seed, Tuple const& tuple)
          {
            hash_combine(seed, get<0>(tuple));
          }
        };
    }

    template <typename ... TT>
    struct hash<std::tuple<TT...>>
    {
        size_t
        operator()(std::tuple<TT...> const& tt) const
        {
            size_t seed = 0;
            HashValueImpl<std::tuple<TT...> >::apply(seed, tt);
            return seed;
        }

    };
}

/*
Utils function
*/
const hostname_t borrow_hostname(const bt_event *event){
    const bt_stream *stream = bt_event_borrow_stream_const(event);
    const bt_trace *trace = bt_stream_borrow_trace_const(stream);
    const bt_value *host_name_str = bt_trace_borrow_environment_entry_value_by_name_const(trace, "hostname");
    return  bt_value_string_get(host_name_str);
}

process_id_t borrow_process_id(const bt_event *event){
    const bt_field *common_context_field = bt_event_borrow_common_context_field_const(event);
    const bt_field *field = bt_field_structure_borrow_member_field_by_index_const(common_context_field, 0);
    return bt_field_integer_signed_get_value(field);
}

thread_id_t borrow_thread_id(const bt_event *event){
    const bt_field *common_context_field = bt_event_borrow_common_context_field_const(event);
    const bt_field *field = bt_field_structure_borrow_member_field_by_index_const(common_context_field, 1);
    return bt_field_integer_unsigned_get_value(field);
}

template <typename T>
std::string to_string_with_precision(const T a_value, const std::string extension, const int n = 2)
{
    std::ostringstream out;
    out.precision(n);
    out << std::fixed << a_value << extension;
    return out.str();
}

template <typename T>
std::string format_byte(const T duration) {
<%[  ['TB',  '1e+12'],
     ['GB', '1e+9'],
     ['MB',   '1e+6'],
     ['kB',   '1e+3'],
     ['B', '1']].each do | unit, factor |  %>
    const double <%= unit %> = duration / <%= factor %>;
    if (<%= unit %> >= 1.) {
        return  to_string_with_precision(<%= unit %>, "<%= unit %>");
    }
<% end %>
    return "";
}


template <typename T>
std::string format_time(const T duration) {
<% [['h',  '3.6e+12'],
    ['min', '6e+10'],
    ['s', '1e+9'],
    ['ms', '1e+6'],
    ['us', '1e+3'],
    ['ns', '1']].each do | unit, factor |  %>
    const double <%= unit %> = duration / <%= factor %>;
    if (<%= unit %> >= 1.) {
        return  to_string_with_precision(<%= unit %>, "<%= unit %>");
    }
<% end %>
    return "";
}

/*
Class for time
 */

struct StatIprof_string {
    std::string time;
    std::string time_ratio;
    std::string count;
    std::string avg;
    std::string min;
    std::string max;
};

class StatIprof {
    uint64_t _start;

  public:
    uint64_t _total_time{1};
    void start(const int64_t);
    void stop(const int64_t);
    void delta(const uint64_t);
    void merge(StatIprof);
    StatIprof_string to_string(const uint64_t);

    //Used in merge
    uint64_t _count{0};
    uint64_t _min{ULONG_MAX};
    uint64_t _max{0};
    uint64_t _time{0};

};

void StatIprof::start(const int64_t start) {
   _start  = start;
}

void StatIprof::stop(const int64_t stop) {
   const uint64_t  delta = stop - _start;
   _min = std::min(_min,delta);
   _max = std::max(_max,delta);
   _count++;
   _time += delta;
}

void StatIprof::delta(const uint64_t delta) {
   _min = std::min(_min,delta);
   _max = std::max(_max,delta);
   _count++;
   _time += delta;
}

void StatIprof::merge(StatIprof st) {
   _min = std::min(_min,st._min);
   _max = std::max(_max,st._max);
   // total can overflow. Need to handle that correctly at some point...
   _count += st._count;
   _time += st._time;
}

<% { "StatTime" => "format_time",
     "StatByte" => "format_byte" }.each do |n,t| %>
class <%= n %>: public StatIprof {
   public:
     StatIprof_string to_string(const uint64_t total_time){
        const double avg = _count ? _time / _count : 0.;
        return StatIprof_string{<%= t %>(_time), // Time
                                to_string_with_precision( (100.*_time / total_time), "%"), // Percent
                                to_string_with_precision(_count,"",0), // Count
                                <%= t %>(avg),
                                <%= t %>(_min),
                                <%= t %>(_max)};
    }
};
<% end %>


<%# Glolbal variable %>
std::unordered_map<hpt_device_command_name_t, StatTime> device_id_result;
std::unordered_map<hpt_command_name_t, StatTime> api_call;
std::unordered_map<hpt_command_name_t, StatByte> memory_trafic;
std::unordered_map<hp_device_t, std::string> device_to_name;

<%#
   _
  |_) ._ o ._ _|_    /\  ._ ._ _.
  |   |  | | | |_   /--\ |  | (_| \/
                                  /
%>

<% l_menbers = ['command_name', 'time','time_ratio','count','avg','min','max'] %>
<% d_headers = [ ["StatTime","format_time",  [ 'Name', 'Time', 'Time(%)', 'Calls', 'Average', 'Min', 'Max'] ],
                 ["StatByte", "format_byte", [ 'Name', 'Byte', 'Byte(%)', 'Calls', 'Average', 'Min', 'Max'] ] ]  %>

 <% d_headers.each do | main_type, main_function, l_headers | %>
void print_array(std::unordered_map<thapi_command_name, <%= main_type %> > aggregated, std::string header) {

    uint64_t total_time{0};
    uint64_t total_count{0};
    for (std::pair<thapi_command_name,  <%= main_type %> > element: aggregated) {
        total_time += element.second._time;
        total_count += element.second._count;
   }
   if (!total_count) {
        return;
   }
   std::cout << header << std::endl;

<%# Need to be bigger than the header %>
<% l_menbers.zip(l_headers).each do |v, n| %>
   uint64_t len_max_<%= v %> = <%= n.size() %>;
<% end %>

<%# Need to be bigger than the footer %>
   len_max_command_name = std::max(len_max_command_name,  uint64_t{<%= "Total".size() %>} );
   len_max_time = std::max(len_max_time, <%= main_function %>(total_time).size());
   len_max_count = std::max(len_max_count, to_string_with_precision(total_count,"",0).size() );

<%# Need to be bigger than the body %>
   for (std::pair<thapi_command_name,  <%= main_type %> > element: aggregated) {
       len_max_command_name =  std::max(len_max_command_name,  element.first.size());
       const auto [time, time_ratio, count, avg, min, max ] = element.second.to_string(total_time);
  <% l_menbers.drop(1).each do |v| %>
       len_max_<%= v %> = std::max(len_max_<%= v %>, <%= v %>.size());
<% end %>
   }

<%# Sort the table %>
   std::vector<std::pair<thapi_command_name,  <%= main_type %> >> array_sorted(aggregated.begin(), aggregated.end());
   std::sort(array_sorted.begin(), array_sorted.end(), [](auto a, auto b) { return a.second._time > b.second._time;} );

<%# Print Header %>
   std::cout
<% l_menbers.zip(l_headers).each do |v, n| %>
   << std::setw(len_max_<%= v %>) << std::right << "<%= n %>" << " | "
<% end %>
   << std::endl;

<%# Print Body %>
   for (std::pair<thapi_command_name,  <%= main_type %> > element: array_sorted) {
        const thapi_command_name command_name = element.first;
        const auto [time, time_ratio, count, avg, min, max ] = element.second.to_string(total_time);
        std::cout
        <% l_menbers.each do |v | %>
        << std::setw(len_max_<%= v %>) << std::right << <%= v %> << " | "
        <% end %>
        << std::endl;
    }

<%# Print footer %>
   std::cout << std::setw(len_max_command_name) << std::right << "Total" << " | "
             << std::setw(len_max_time) << std::right << <%= main_function %>(total_time) << " | "
             << std::setw(len_max_time_ratio) << std::right << "100.00%" << " | "
             << std::setw(len_max_count) << std::right <<  to_string_with_precision(total_count,"",0) << " | "
             << std::endl;
}

<% end %>

<%#
   _
  |_) ._ o ._ _|_    /\  ._ ._ _.
  |   |  | | | |_   /--\ |  | (_| \/
                                  /
%>

   <% output = [ ['StatTime', 'api_call', 'API calls', 'hpt_t',
                    [ ['hostname_t','Hostnames','Hostname'],
                      ['process_id_t','Processes','Process'],
                      ['thread_id_t','Threads','Thread'] ] ],
                 ['StatTime', 'device_id_result','Device profiling', 'hpt_device_t',
                    [ ['hostname_t','Hostnames','Hostname'],
                      ['process_id_t','Processes','Process'],
                      ['thread_id_t','Threads','Thread'] ,
                      ['thapi_device_id','Devices','Device'] ] ],
                 ['StatByte', 'memory_trafic', 'Explicit memory trafic', 'hpt_t',
                    [ ['hostname_t','Hostnames','Hostname'],
                      ['process_id_t','Processes','Process'],
                      ['thread_id_t','Threads','Thread'] ] ],
   ] %>

<% output.each do |main_type, result,header, type, var| %>
void print_compact_<%= result %>(){
    <% var.each do |t,n,_ | %>
   std::set<<%= t %>> s_<%= n %>;
    <% end %>
    <%# Agreagate API Call Result and compute total time spend %>
   std::unordered_map<thapi_command_name, <%= main_type %> > aggregated;
   for (auto element: <%= result %>)
   {
       auto [ <%= var.map{ |t,n| n}.join(',') %>,command_name ] = element.first;
    <% var.each do | _, n,_ | %>
       s_<%= n %>.insert(<%= n %>);
    <% end %>
       const <%= main_type %> time = element.second;
       aggregated[command_name].merge(time);
    }

   std::ostringstream oss;
   oss << "<%= header %>"
    <% var.each do | _, n,_ | %>
       << " | " << s_<%= n %>.size() << " <%= n %>"
    <% end %>
        << std::endl;
   print_array(aggregated,oss.str());
   std::cout << std::endl;
};

void print_extented_<%= result %>(){

  <% args = var.map{ |t,_,n| n}.join(',') %>
  std::unordered_map< <%= type %>, std::unordered_map<thapi_command_name, <%= main_type %> >> d;
  for (auto [s, time]: <%= result %> ) {
    auto [<%= args %>, command_name] = s;
    d[ <%= type %>( <%= args %> )][command_name].merge(time);
  }

  std::vector<std::pair< <%= type %> , std::unordered_map<thapi_command_name,  <%= main_type %> >>> array_sorted(d.begin(), d.end());
  std::sort(array_sorted.begin(), array_sorted.end(),   [](auto a, auto b) { return a.first > b.first ; } );

  for (auto[s, aggregated]: array_sorted) {
    auto [ <%= args %> ] = s;
    std::ostringstream oss;
    oss <<  "<%= header %>"
     <% var.each do | _,_, n | %>
        << " | <%= n %>: " << <%= n %>
     <% end %>
     <% if result == 'device_id_result' %>
        <<  " (" << device_to_name[hp_device_t(Hostname,Process,Device)] << ")"
     <% end %>
        << std::endl;
     print_array(aggregated, oss.str());
     std::cout << std::endl;
   }
};
<% end %>
